/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import kotlin.math.abs
import org.example.day02_is_safe

fun day01_part1(): Int {

    // Read input
    val lines = read_lines("src/main/resources/day01.txt")

    // Convert lines to pairs of ints
    val pairs: List<Pair<Int, Int>> = lines.map { line: String ->
        val parts = line.split("   ")
        val n1 = parts[0].toInt()
        val n2 = parts[1].toInt()

        Pair(n1, n2)
    }

    // Split up pairs into their own lists and sort them
    val listA = pairs.map { pair -> pair.first }.sorted()
    val listB = pairs.map { pair -> pair.second }.sorted()

    // Get the sum of distances
    var sum = 0
    for (i in listA.indices) {
        sum += abs(listA[i] - listB[i])
    }

    return sum
}

fun day01_part2(): Int {

    // Read input
    val lines = read_lines("src/main/resources/day01.txt")

    // Convert lines to pairs of ints
    val pairs: List<Pair<Int, Int>> = lines.map { line: String ->
        val parts = line.split("   ")
        val n1 = parts[0].toInt()
        val n2 = parts[1].toInt()

        Pair(n1, n2)
    }

    // Split up pairs into their own lists
    val listA = pairs.map { pair -> pair.first }
    val listB = pairs.map { pair -> pair.second }

    // Build frequency map from right list
    var freqMap = HashMap<Int, Int>()
    listB.forEach { n -> 
        if (freqMap.containsKey(n)) {
            val old = freqMap.getValue(n)
            freqMap.replace(n, old+1)
        } else {
            freqMap.put(n, 1)
        }
    }

    // Calculate similarity using frequency map
    var similarity = 0
    listA.forEach { n ->
        if (freqMap.containsKey(n)) {
            val occurences = freqMap.getValue(n)
            similarity += n * occurences
        }
    }

    return similarity
}

fun day02_part1(): Int {

    // Read input as list of list of ints

    val lines = read_lines("src/main/resources/day02.txt")

    val reports: List<List<Int>> = lines.map { line: String ->
        val parts = line.split(" ")
        parts.map {
            s: String -> s.toInt()
        }
    }

    // Figure out which reports are safe
    val safeReports = (reports.map {
        levels: List<Int> -> day02_is_safe(levels)
    }).filter { isSafe -> isSafe }


    return safeReports.size
}

fun day02_part2(): Int {

    // Read input as list of list of ints

    val lines = read_lines("src/main/resources/day02.txt")

    val reports: List<List<Int>> = lines.map { line: String ->
        val parts = line.split(" ")
        parts.map {
            s: String -> s.toInt()
        }
    }

    val safeReports = (reports.map { levels: List<Int> -> 
        // Generate permutations by excluding items
        val permutations: List<List<Int>> = (0..levels.size).map {
            i -> levels.filterIndexed { j, _ -> j != i }
        }

        // Check if one of the permuations are safe
        permutations.map {
            perm -> day02_is_safe(perm)
        }.any { isSafe -> isSafe }
    }).filter { isSafe -> isSafe }

    return safeReports.size
}

fun day03_part1(): Int {

    val str = read_text("src/main/resources/day03.txt")

    val regex = """mul\(\d+,\d+\)""".toRegex()

    val matches = regex.findAll(str)

    var sum = 0
    for (match in matches) {
        val mul = match.value // mul(a,b)
        val argStr = mul.substring(4, mul.length - 1) // a,b
        val args = argStr.split(",").map { s: String -> s.toInt() } // [a, b]

        sum += args[0] * args[1]
    }

    return sum
}

fun day03_part2(): Int {

    val str = read_text("src/main/resources/day03.txt")

    val regex = """(mul\(\d+,\d+\))|(don't\(\))|(do\(\))""".toRegex()

    val matches = regex.findAll(str)

    var sum = 0
    var doMul = true
    for (match in matches) {

        val stmt = match.value

        if (stmt.equals("do()")) { // do()
            doMul = true
        } else if (stmt.equals("don't()")) { // don't()
            doMul = false
        } else if (doMul) { // mul(a,b)
            val argStr = stmt.substring(4, stmt.length - 1) // a,b
            val args = argStr.split(",").map { s: String -> s.toInt() } // [a, b]
    
            sum += args[0] * args[1]
        }

    }

    return sum
}

fun day04_part1(): Int {

    val rows = read_lines("src/main/resources/day04.txt")
    val cols: List<String> = rows[0].indices.map { y: Int ->
        rows.indices.map { x -> rows[x][y] }.joinToString("")
    }

    val LastCol = cols.size-1
    val LastRow = rows.size-1
    val seDiags: List<String> = (0..LastCol).map { c: Int -> day04_get_se_diag_from(rows, 0, c) } + (1..LastRow).map { r: Int -> day04_get_se_diag_from(rows, r, 0) }
    val swDiags: List<String> = (LastCol.downTo(0)).map { c: Int -> day04_get_sw_diag_from(rows, 0, c) } + (LastRow.downTo(1)).map { r: Int -> day04_get_sw_diag_from(rows, r, LastCol) }

    val rgx = """(XMASAMX)|(SAMXMAS)|(XMAS)|(SAMX)""".toRegex()
    val horizCounts = rows.map { str: String -> day04_count_matches(rgx.findAll(str)) }.reduce { sum, n -> sum + n }
    val vertCounts = cols.map { str: String -> day04_count_matches(rgx.findAll(str)) }.reduce { sum, n -> sum + n }
    val seDiagCounts = seDiags.map { str: String -> day04_count_matches(rgx.findAll(str)) }.reduce { sum, n -> sum + n }
    val swDiagCounts = swDiags.map { str: String -> day04_count_matches(rgx.findAll(str)) }.reduce { sum, n -> sum + n }

    return horizCounts + vertCounts + seDiagCounts + swDiagCounts
}

fun day04_part2(): Int {
    return 0
}

fun day05_part1(): Int {

    // Split up input into the 2 sections
    val lines = read_lines("src/main/resources/day05.txt")
    val i = lines.indexOfFirst { it.equals("") }
    val section1 = lines.subList(0, i)
    val section2 = lines.subList(i+1, lines.size)


    // Build ordering map from section 1
    // [ number ] -> set of numbers that must follow
    val orderingMap: HashMap<Int, HashSet<Int>> = hashMapOf()

    section1.forEach { str: String ->
        val nums = str.split("|").map { it.toInt() }

        val k = nums[0]

        if (orderingMap.contains(k)) {
            val set = orderingMap.getValue(k)
            set.add(nums[1])
            orderingMap.replace(k, set)
        } else {
            orderingMap.put(k, hashSetOf(nums[1]))
        }
    }

    // Parse section 2 into list of int arrays
    val updates = section2.map { line: String -> line.split(",").map { it.toInt() } }

    // Sum the middle numbers
    val result = updates.map { day05_verify_update(it, orderingMap) }.reduce { sum, n -> sum + n }

    return result

}

fun day05_part2(): Int {
    // Split up input into the 2 sections
    val lines = read_lines("src/main/resources/day05.txt")
    val i = lines.indexOfFirst { it.equals("") }
    val section1 = lines.subList(0, i)
    val section2 = lines.subList(i+1, lines.size)


    // Build ordering map from section 1
    // [ number ] -> set of numbers that must follow
    val orderingMap: HashMap<Int, HashSet<Int>> = hashMapOf()

    section1.forEach { str: String ->
        val nums = str.split("|").map { it.toInt() }

        val k = nums[0]

        if (orderingMap.contains(k)) {
            val set = orderingMap.getValue(k)
            set.add(nums[1])
            orderingMap.replace(k, set)
        } else {
            orderingMap.put(k, hashSetOf(nums[1]))
        }
    }

    // Parse section 2 into list of int arrays
    val updates = section2.map { line: String -> line.split(",").map { it.toInt() } }

    // Find the incorrect updates and get the corrected middle numbers
    val result = updates.map { update: List<Int> ->
        if (day05_verify_update(update, orderingMap) == 0) {
            day05_correct_update(update, orderingMap)
        } else { 0 }
    }.reduce { sum, n -> sum + n }

    return result
}

fun main() {

    println("day05, part 1 solution is '${day05_part1()}'")
    println("day05, part 2 solution is '${day05_part2()}'")

}
